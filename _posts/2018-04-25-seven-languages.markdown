---
layout: post
title: "Book Review - Seven Languages in Seven Weeks"
date: 2018-04-25 12:00:00
image: '/assets/img/'
description: 'An opinionated review of the popular book'
tags:
- programming languages
- books
categories:
- Book Review
---

First of all, let me explain why I decided to read through this book in the first place. As someone who's been programming pretty much exclusively in Java and Javascript for the past couple years at my job, I decided it might be a good idea to try out some other programming languages outside of work to broaden my perspective. I've dabbled a bit with other procedural / object oriented languages in the past, but after working with Redux and using some of Java 8's more "functional" features I thought of giving some more functional languages a try. 

I mentioned to my manager in our weekly one on one meeting that I was taking more of an interest in functional programming. He told me there was a book he read called "Seven Languages in Seven Weeks" that went through a few different programming paradigms and there were some functional languages covered in the book. This was the first time I had ever heard of the book, and since I wasn't totally sold on any one new language to try out I decided to give it a go.

Going into the book I tried to give myself pretty realistic expectations. I don't think you can expect anyone to master a programming language in a week's time. What I think you could learn would be some basic syntax and probably enough language features to solve a few smaller problems. What I was hoping to get out of the book wasn't to really learn or master any of these languages, but rather to find out what different approaches each language took to solving problems.

The seven languages covered in the book in order are Ruby, Io, Prolog, Scala, Erlang, Clojure, and Haskell. Out of the seven, I found Ruby, Io, and Scala to be the most intuitive, probably because they were the three that most closely resemble languages I'm used to using. Having worked with Ruby a bit in the past, I found the first chapter more of a refresher course than anything else with an interesting dive into Ruby's metaprogramming features at the end of the chapter. Io had a very interesting take on concurrency with its messaging features, but the prototypal inheritence model wasn't that much of a departure from what I've been working with in the Javascript world to really interest me much. 

For me Erlang and Haskell were by far the most challenging. With Erlang, I think the combination of a foreign looking syntax and a lack of real motivation on my part to dive into the language got in the way of finding an appreciation for it. While the motivation was there for me to learn Haskell, the 

Clojure seemed a bit easier for me to work with, despite my not having much exposure to a Lisp like language outside of a course I took in University many years ago. I think the combination of having a super simple syntax and build tools like Leiningen that use some JVM conventions I'm used to helped a lot with getting more productive quickly. 